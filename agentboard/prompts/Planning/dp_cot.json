{
    "examples": ["input = [-2, -2, -3, 5, 5, -4] Thought: Let's solve input = [-2, -2, -3, 5, 5, -4]. We could simulate dynamic programming step by step.\n dp[5] = max(input[5], 0) = max(-4, 0) = 0\ndp[4] = max(input[4], input[5], 0) = max(5, -4, 0) = 5\ndp[3] = max(dp[4], input[3] + dp[5], 0) = max(5, 5 + 0, 0) = 5\ndp[2] = max(dp[3], input[2] + dp[4], 0) = max(5, -3 + 5, 0) = 5\ndp[1] = max(dp[2], input[1] + dp[3], 0) = max(5, -2 + 5, 0) = 5\ndp[0] = max(dp[1], input[0] + dp[2], 0) = max(5, -2 + 5, 0) = 5\n\nFinally, we reconstruct the lexicographically smallest subsequence that fulfills the task objective by selecting numbers as follows. We store the result on a list named \"output\".\n\nLet can_use_next_item = True.\nSince dp[0] != input[0] + dp[2] (5 != -2 + 5) or can_use_next_item == False, we store output[0] = 2. We update can_use_next_item = True.\nSince dp[1] != input[1] + dp[3] (5 != -2 + 5) or can_use_next_item == False, we store output[1] = 2. We update can_use_next_item = True.\nSince dp[2] != input[2] + dp[4] (5 != -3 + 5) or can_use_next_item == False, we store output[2] = 2. We update can_use_next_item = True.\nSince dp[3] == input[3] + dp[5] (5 == 5 + 0) and can_use_next_item == True, we store output[3] = 1. We update can_use_next_item = False.\nSince dp[4] != input[4] (5 != 5) or can_use_next_item == False, we store output[4] = 2. We update can_use_next_item = True.\nSince dp[5] != input[5] (0 != -4) or can_use_next_item == False, we store output[5] = 2.\n\nReconstructing all together, output=[2, 2, 2, 1, 2, 2]"],
    "system_msg": "You are a helpful assistant.",
    "instruction": "Given a sequence of integers, find a subsequence with the highest sum, such that no two numbers in the subsequence are adjacent in the original sequence.\n\nOutput a list with \"1\" for chosen numbers and \"2\" for unchosen ones. If multiple solutions exist, select the lexicographically smallest. "
}